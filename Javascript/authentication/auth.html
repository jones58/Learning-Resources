<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>Authenticating web apps</title><link rel="preload" href="/assets/fonts/GT-Eesti-Text-Light-subset.woff2" as="font" type="font/woff2" crossorigin /><link rel="icon" href="/assets/favicon.svg" /><link href="/assets/css/styles.css" rel="stylesheet" /></head><body><div><header class="hstack jc-between pad-lg"><a href="/" aria-label="Home"><img src="/assets/images/logo.svg" width="100" alt /></a><nav id="global-nav"><ul role="list" class="hstack"><li><a class="global-nav__link" href="/course/introduction/">Course</a></li><li><a class="global-nav__link" href="/resources/introduction/">Resources</a></li><li><a class="global-nav__link" href="/about/">About</a></li></ul></nav></header><div class="center"><div class="layout"><aside></aside><main id="main"><div><header class="vstack gap-xl pad-xl stripes"><div class="vstack" data-gap="md"><h1 class="highlight bg-primary">Authenticating web apps</h1><p class="highlight fz-lg">Learn how to safely store passwords, and identify returning users with cookies and sessions</p><ul role="list" class="hstack gap-sm wrap"><li class="highlight fz-sm fw-bold" style="--bg: var(--bg-400)">js</li><li class="highlight fz-sm fw-bold" style="--bg: var(--bg-400)">express</li><li class="highlight fz-sm fw-bold" style="--bg: var(--bg-400)">auth</li></ul></div><div class="hstack wrap"><a href="https://github.com/foundersandcoders/auth-challenge" target="_blank" rel="noopener" class="button" style="--bg: var(--primary); --bg-hover: var(--primary-dark)">View challenge repo<svg viewBox="0 0 20 20" fill="currentColor" width="16" height="16"><path fill-rule="evenodd" d="M4.25 5.5a.75.75 0 00-.75.75v8.5c0 .414.336.75.75.75h8.5a.75.75 0 00.75-.75v-4a.75.75 0 011.5 0v4A2.25 2.25 0 0112.75 17h-8.5A2.25 2.25 0 012 14.75v-8.5A2.25 2.25 0 014.25 4h5a.75.75 0 010 1.5h-5z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M6.194 12.753a.75.75 0 001.06.053L16.5 4.44v2.81a.75.75 0 001.5 0v-4.5a.75.75 0 00-.75-.75h-4.5a.75.75 0 000 1.5h2.553l-9.056 8.194a.75.75 0 00-.053 1.06z" clip-rule="evenodd"></path></svg></a><a href="https://github.com/foundersandcoders/coursebook/issues/new?title=%5Blearn%2Fauth%5D&amp;labels=feedback" target="_blank" rel="noopener" class="button">Leave feedback<svg viewBox="0 0 20 20" fill="currentColor" width="16" height="16"><path fill-rule="evenodd" d="M10 2c-2.236 0-4.43.18-6.57.524C1.993 2.755 1 4.014 1 5.426v5.148c0 1.413.993 2.67 2.43 2.902 1.168.188 2.352.327 3.55.414.28.02.521.18.642.413l1.713 3.293a.75.75 0 001.33 0l1.713-3.293a.783.783 0 01.642-.413 41.102 41.102 0 003.55-.414c1.437-.231 2.43-1.49 2.43-2.902V5.426c0-1.413-.993-2.67-2.43-2.902A41.289 41.289 0 0010 2zM6.75 6a.75.75 0 000 1.5h6.5a.75.75 0 000-1.5h-6.5zm0 2.5a.75.75 0 000 1.5h3.5a.75.75 0 000-1.5h-3.5z" clip-rule="evenodd"></path></svg></a></div></header><div style="margin: 4rem 0" class="flow"><p>Applications often store information specific to individual users. It is important to only allow access to the correct people, to avoid potentially malicious actors stealing or deleting private data. The term <em>authentication</em> refers to the process of verifying the identity of a specific user; <em>authorization</em> refers to verifying that this user is allowed to do something.</p>
<div class="box  content flow">
<p>Authentication is a complex topic with serious repercussions for getting it wrong. To keep this workshop focused we are going to focus on the necessary concepts to get a simple signup/login system working. This means we will be skipping over the “glue code” (e.g. the actual server, HTML forms etc).</p>
</div>
<h2 id="verifying-users-with-passwords">Verifying users with passwords <a class="heading-anchor" href="#verifying-users-with-passwords">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>The simplest way to verify a user is by asking them for a secret when they create an account. They can then provide this secret when they want access—since only they should know it you can trust that they are who they say they are.</p>
<p>Early versions of password protection were simple:</p>
<ol>
<li>Ask user for a password on account creation</li>
<li>Store the password in database</li>
<li>(later) Ask user for a password again on login</li>
<li>Read password from database and check they are the same</li>
</ol>
<p>Unfortunately storing passwords in “plaintext” like this is problematic. Anybody with access to the DB can see every user’s password—this includes employees of the business and any hackers who manage to connect to the DB.</p>
<p>Leaking passwords like this is especially bad because most users re-use the same password for many sites. You may not be too worried about the security of your dog-rating app, but some of your users probably gave you their bank password.</p>
<p>Ideally we need a way to verify passwords without actually storing the password.</p>
<h2 id="hashing-passwords">Hashing passwords <a class="heading-anchor" href="#hashing-passwords">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Hashing is when you use a mathematical process (algorithm) to convert a string into a different one. Hashes are:</p>
<ul>
<li>One-way: it should be impossible to reverse the process.</li>
<li>Deterministic: hashing the same string always gives the same result.</li>
<li>Unique: hashing a different string should never create the same result.</li>
</ul>
<p>Here’s a quick way to create a hash using Node:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"node:crypto"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> password <span class="token operator">=</span> <span class="token string">"hunter2"</span><span class="token punctuation">;</span><br><br><span class="token comment">// Hash string with the SHA256 algorithm and output in hexadecimal format</span><br><span class="token keyword">const</span> hashed <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span><span class="token string">"sha256"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token string">"hex"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// "f52fbd32b2b3b86ff88ef6c490628285f482af15ddcb29541f94bcf526a3f6c7"</span></code></pre>
<p>There is no way to turn the “f52fb…” hash back into “hunter2”, so it’s safe to store in our DB. A different password will never create the same hash, so there won’t be conflicts.</p>
<p>Here’s the flow from above updated to use hashing:</p>
<ol>
<li>Ask user for a password on account creation</li>
<li><em>Hash the password, then store the hash in database</em></li>
<li>(later) Ask user for a password again on login</li>
<li><em>Hash the provided password</em></li>
<li>Read the hash from the DB and check they are the same</li>
</ol>
<h2 id="salting-password-hashes">Salting password hashes <a class="heading-anchor" href="#salting-password-hashes">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>There is still a security problem here: hashing the same password always creates the same output. This lets a hacker who has stolen your DB use something called a “rainbow table” to make finding passwords easier.</p>
<p>A rainbow table is a big list of pre-computed hashes for common passwords. This lets them quickly match pre-computed hashes to those in your DB to find out what password was used to create the hash. This is <em>much</em> faster than hashing each password before comparing, since good hashing algorithms are deliberately slow to prevent this type of brute-force attack.</p>
<p>We can avoid this problem by ensuring each hash is truly unique. If we add a random string to the password before hashing then the result will always be different. We must then store the salt in the DB alongside the password, as we will need it to recreate the hash when we verify a user.</p>
<ol>
<li>Ask user for a password on account creation</li>
<li><em>Generate a random salt</em></li>
<li><em>Hash the password + salt, then store the hash and salt in database</em></li>
<li>(later) Ask user for a password again on login</li>
<li>Read the hash and salt from the DB</li>
<li><em>Hash the provided password + stored salt</em></li>
<li>Check the hashes are the same</li>
</ol>
<p>It is now impossible for any of these hashes to be pre-computed, since the hacker would need to know the salt in advance…</p>
<h2 id="using-b-crypt-to-hash-passwords">Using BCrypt to hash passwords <a class="heading-anchor" href="#using-b-crypt-to-hash-passwords">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Our sign up/log in process has gotten quite complex. There are many moving parts to get right, and any flaw could be exploited by a hacker. It is a good idea to rely on a popular battle-tested library to implement these features for us instead of trying to write them ourselves.</p>
<p>The <a href="https://github.com/dcodeIO/bcrypt.js"><code>bcryptjs</code></a> npm package provides simple methods for hashing a password (with salt) and comparing a password to a hash. Let’s see how we’d use it to hash a password:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> bcrypt <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"bcryptjs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> password <span class="token operator">=</span> <span class="token string">"hunter2"</span><span class="token punctuation">;</span><br><br>bcrypt<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>password<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">hash</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// $2a$10$n1etzOWCrAtJGQIDoaw0mun1ojnIjA2UaiJ8DkL76ljhGa/cZCQtq</span></code></pre>
<p>The <code>.hash</code> method is designed to be slow, to make brute-force attacks harder. You control how slow it should be using the second argument (<code>12</code> is a good compromise between speed and security). It returns a promise—you need to wait for this to resolve before you can access the hash.</p>
<p>The <code>.compare</code> method lets us compare the hash to passwords to see if they match:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">//...</span><br><br>bcrypt<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>password<span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">hash</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  bcrypt<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"hunter2"</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// true</span><br>  bcrypt<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"incorrect"</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// false</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>This method returns a promise that resolves with a boolean telling you whether the password matches the hash.</p>
<div class="box box-default content flow">
<p>Make sure you pass the hash as the <em>second</em> argument, otherwise the comparison won’t work.</p>
</div>
<h2 id="keeping-users-logged-in">Keeping users logged in <a class="heading-anchor" href="#keeping-users-logged-in">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>We can verify that a user’s submitted password matches the one they previously signed up with, but this isn’t enough for an authentication system. Users do not want to type their password in every time they load a new page or take an action. We need a way to persist our verification across many requests.</p>
<p>HTTP is a “stateless” protocol. This means each new request to your server is totally independent of any other. There is no way by default for a request to contain information from previous requests.</p>
<p>Cookies were introduced in 1994 as a way for web browsers to store information on behalf of the server. The response to one request can contain a cookie; the browser will store this cookie and automatically include it on <strong>all future requests</strong> to the same domain.</p>
<h2 id="how-cookies-work">How cookies work <a class="heading-anchor" href="#how-cookies-work">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>A cookie is just a standard HTTP header. They can be set by a server including the <code>set-cookie</code> header in a response. Here’s an example HTTP response:</p>
<pre><code>HTTP/1.1 200 Ok
content-type: text/html
set-cookie: userid=1234

&lt;h1&gt;Hello&lt;/h1&gt;
</code></pre>
<p>That <code>set-cookie</code> header tells the browser to store a cookie with a name of <code>&quot;userid&quot;</code> and a value of <code>&quot;1234&quot;</code>. This cookie is then sent on all future requests to this domain via the <code>cookie</code> request header. Here’s an example HTTP request:</p>
<pre><code>GET /about HTTP/1.1
accept: text/html
cookie: userid=1234
</code></pre>
<p>The server can read the <code>cookie</code> header to retrieve the info it previously stored.</p>
<h3 id="cookie-attributes">Cookie attributes <a class="heading-anchor" href="#cookie-attributes">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h3>
<p>Cookies also support extra attributes to customise their behaviour. These can be set after the cookie value itself, like this:</p>
<pre><code>set-cookie: userid=1234; Max-Age=60; HttpOnly; SameSite=Lax
</code></pre>
<h4 id="expiry">Expiry <a class="heading-anchor" href="#expiry">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h4>
<p>By default a cookie only lasts as long as the user is browsing. As soon as they close their tabs the cookie will be deleted by the browser. The server can specify an expiry time for the cookie. There are two ways to control this: <code>Expires</code> and <code>Max-Age</code>. <code>Expires</code> lets you set a specific date it should expire on; <code>Max-Age</code> lets you specify how many seconds from now the cookie should last.</p>
<h4 id="security">Security <a class="heading-anchor" href="#security">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h4>
<p>These options help make your cookies more secure:</p>
<ul>
<li><code>HttpOnly</code> stops client-side JavaScript from accessing cookies. This can prevent malicious JS code from reading your cookies (“Cross-site Scripting” or XSS).</li>
<li><code>Same-Site=Lax</code> stops the cookie from being sent on requests made from other domains. Without this other sites can fake requests from a logged in user (“Cross-site Request Forgery” or CSRF).</li>
<li><code>Secure</code> will ensure the cookie is only set for encrypted (<code>https</code>) connections. You shouldn’t use this in development (since <code>localhost</code> doesn’t use <code>https</code>) but it’s a good idea in production.</li>
</ul>
<h2 id="cookies-in-node">Cookies in Node <a class="heading-anchor" href="#cookies-in-node">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Since cookies are just HTTP headers you can set them and read them in a Node server:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// responding to one request...</span><br>response<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"set-cookie"</span><span class="token punctuation">,</span> <span class="token string">"hello=world; HttpOnly; Max-Age=60; SameSite=Lax"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// reading a later request...</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"cookie"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// "hello=world; HttpOnly; Max-Age=60; SameSite=Lax"</span></code></pre>
<p>Working with the raw headers like this is awkward though. Everything is just a big string, so it’s hard to create a cookie with the right options and even harder to extract the cookie value from the header. There could also be <em>multiple</em> cookies within one header.</p>
<h2 id="cookies-in-express">Cookies in Express <a class="heading-anchor" href="#cookies-in-express">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Express provides helper methods for setting cookies. The <code>response.cookie</code> method lets you set a cookie by providing the name, value and any options:</p>
<pre class="language-js"><code class="language-js">response<span class="token punctuation">.</span><span class="token function">cookie</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>  <span class="token literal-property property">httpOnly</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">maxAge</span><span class="token operator">:</span> <span class="token number">6000</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">sameSite</span><span class="token operator">:</span> <span class="token string">"lax"</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// This sets the same `set-cookie` header as before</span></code></pre>
<p>You can also delete a cookie using the <code>response.clearCookie</code> method. This takes the name of the cookie to delete and sets the right header to remove it:</p>
<pre class="language-js"><code class="language-js">response<span class="token punctuation">.</span><span class="token function">clearCookie</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// This sets a header that deletes the previous cookie in the browser</span></code></pre>
<p>Express does not have a built-in way to <em>read</em> cookies. You need to install the <code>cookie-parser</code> middleware from npm for this. It works just like the built-in body-parsing middleware—it grabs the header, parses the string into an object, then attaches it to the <code>request</code> object for you.</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> cookieParser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"cookie-parser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>server<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cookieParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Reading a later request...</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>cookies<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// { hello: "world" }</span></code></pre>
<h2 id="using-cookies-for-authentication">Using cookies for authentication <a class="heading-anchor" href="#using-cookies-for-authentication">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Now we know how to use cookies to store info in the browser we can keep a user logged in. Once we’ve verified their password we can store a cookie that effectively says “this is oli”. On subsequent requests the server would read the cookie to find out which user it came from. E.g. the cookie might look like this: <code>userid=1</code>.</p>
<p>Unfortunately this wouldn’t be very secure. Anyone can send any HTTP headers they like to your server. You could use dev tools to edit your request to send <code>userid=2</code> to pretend to be a totally different user.</p>
<p>We need a way to ensure our cookie hasn’t been tampered with. Luckily cryptography has a solution for us: <a href="https://en.wikipedia.org/wiki/Digital_signature"><em>signatures</em></a>. This means combining a value with a secret in a one-way mathematical operation. This is called a “signature”, and it can only be reproduced by someone with both the value <em>and</em> the secret.</p>
<p>If we send both the value and the signature in the cookie we can recalculate the signature on the server (using the secret) to make sure the cookie wasn’t tampered with. E.g. if someone changed <code>userid=1</code> to <code>userid=2</code> it would break the signature.</p>
<p>Express’ <code>cookie-parser</code> middleware supports signing cookies automatically. You just have to pass a secret in when you initialise the middleware, then set the <code>signed</code> option when you create a cookie:</p>
<pre class="language-js"><code class="language-js">server<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cookieParser</span><span class="token punctuation">(</span><span class="token string">"random-string-that-should-be-an-env-var"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// ...</span><br>response<span class="token punctuation">.</span><span class="token function">cookie</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>  <span class="token literal-property property">signed</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">httpOnly</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">maxAge</span><span class="token operator">:</span> <span class="token number">6000</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">sameSite</span><span class="token operator">:</span> <span class="token string">"lax"</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Now when you read cookies they’ll be available at <code>request.signedCookies</code>:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// Reading a later request...</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>signedCookies<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// { hello: "world" }</span></code></pre>
<p>If the signature didn’t match the cookie will not be present in the object.</p>
<div class="box box-default content flow">
<p>You should use signed cookies for pretty much everything</p>
</div>
<h2 id="stateless-authentication-flow">Stateless authentication flow <a class="heading-anchor" href="#stateless-authentication-flow">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Our current auth flow looks like this:</p>
<ol>
<li>Ask user for a password on login</li>
<li>Read the hash from the DB</li>
<li>Check the hashes are the same with <code>bcrypt.compare</code></li>
<li>Set a signed cookie with any user info we might need</li>
<li>(later) read the cookie to find out info about the user</li>
</ol>
<p>This is known as “stateless” auth, because we store all the info we might need for authentication in the cookie. The server doesn’t need to check the DB to know whether a request is authenticated.</p>
<p>This is convenient but has some downsides:</p>
<ol>
<li>Cookies have a 4kb size limit, so you can’t fit <em>too</em> much info in them.</li>
<li>The server cannot log users out. Any device with a valid cookie is “logged in”.</li>
<li>The server cannot enforce expiry time, since users can edit their cookies in the browser.</li>
</ol>
<p>Ideally we need a system that lets us keep track of who is logged in on the server, so we can revoke that access when necessary.</p>
<h2 id="session-authentication-flow">Session authentication flow <a class="heading-anchor" href="#session-authentication-flow">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Instead of storing all the user info in the cookie, we can just store a random “session ID” that corresponds to info stored in our DB. Now the cookie itself has no power, the <em>server</em> decides whether the user is logged in based on the session info.</p>
<p>Here’s a modified auth flow:</p>
<ol>
<li>Ask user for a password on login</li>
<li>Read the hash from the DB</li>
<li>Check the hashes are the same with <code>bcrypt.compare</code></li>
<li><em>Insert row into <code>sessions</code> table with user info</em></li>
<li>Set a signed cookie with <em>the session ID</em></li>
<li>(later) read the <em>session ID</em> from the cookie</li>
<li><em>(later) look up the session info from the DB</em></li>
</ol>
<p>This avoids all the problems with stateless auth:</p>
<ol>
<li>We only store an ID in the cookie, so the 4kb limit doesn’t matter</li>
<li>The server can log users out by deleting the corresponding row from the DB</li>
<li>The server can store session expiry dates in the DB to ensure an old cookie cannot be reused</li>
</ol>
<p>Here’s roughly how this might be implemented. First we need a table to store our session in:</p>
<pre class="language-sql"><code class="language-sql"><span class="token comment">-- schema.sql</span><br><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> users <span class="token punctuation">(</span><br>  id <span class="token keyword">INTEGER</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> AUTOINCREMENT<span class="token punctuation">,</span><br>  <span class="token comment">-- plus other columns...</span><br><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> sessions <span class="token punctuation">(</span><br>  id <span class="token keyword">TEXT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span><br>  user_id <span class="token keyword">INTEGER</span> <span class="token keyword">REFERENCES</span> users<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span><br>  expires_at <span class="token keyword">DATETIME</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><br><span class="token punctuation">)</span></code></pre>
<p>For now we’re just storing the <code>user_id</code>, which we can use to look up other user info later. We’ll also store the expiry time so we can ensure users aren’t logged in forever.</p>
<p>Then we need a function to generate a random session ID and insert the session:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// model.js</span><br><span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"node:crypto"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Sets the expiry to current date + 7 days</span><br><span class="token keyword">const</span> insert_session <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">INSERT INTO sessions VALUES (<br>  $id,<br>  $user_id,<br>  DATE('now', '+7 days')<br>)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">function</span> <span class="token function">createSession</span><span class="token punctuation">(</span><span class="token parameter">user_id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// quick way to generate a random string in Node</span><br>  <span class="token keyword">const</span> id <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">randomBytes</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">"base64"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  insert_session<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> user_id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// return the generated ID so we can store in a cookie</span><br>  <span class="token keyword">return</span> id<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>We’ll also need function to retrieve a session:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// model.js</span><br><br><span class="token keyword">const</span> select_session <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"><br>  SELECT id, user_id, expires_at<br>  FROM sessions WHERE id = ?<br></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">function</span> <span class="token function">getSession</span><span class="token punctuation">(</span><span class="token parameter">sid</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> select_session<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Now handlers can read the session cookie to find out which user (if any) made the request:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// routes/private.js</span><br><br><span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> sid <span class="token operator">=</span> req<span class="token punctuation">.</span>signedCookies<span class="token punctuation">.</span>sid<span class="token punctuation">;</span><br>  <span class="token keyword">const</span> session <span class="token operator">=</span> model<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>session <span class="token operator">&amp;&amp;</span> session<span class="token punctuation">.</span>user_id<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// we have a logged in user</span><br>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>Private stuff&lt;/h1>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token comment">// request is not authenticated</span><br>    res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>Please log in to view this page&lt;/h1>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Since this logic will be repeated in any request that needs to check the session it would be worth abstracting into an Express middleware.</p>
<h2 id="authentication-summary">Authentication summary <a class="heading-anchor" href="#authentication-summary">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h2>
<p>Things got a little complicated, so let’s recap our final authentication flow to make it clear:</p>
<h3 id="signing-up">Signing up <a class="heading-anchor" href="#signing-up">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h3>
<ol>
<li>User submits their email and password</li>
<li>Hash the password with BCrypt</li>
<li>Insert a new user into the DB to store email and hash</li>
<li>Create new session in the DB</li>
<li>Set a signed cookie with the session ID</li>
<li>Redirect to whatever page comes next</li>
</ol>
<h3 id="logging-in">Logging in <a class="heading-anchor" href="#logging-in">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h3>
<ol>
<li>User submits their email and password</li>
<li>Retrieve the stored user where email matches</li>
<li>Compare submitted password with stored hash</li>
<li>If they match create a new session in the DB</li>
<li>Set a signed cookie with the session ID</li>
<li>Redirect to whatever page comes next</li>
</ol>
<h3 id="checking-auth">Checking auth <a class="heading-anchor" href="#checking-auth">
  <svg
    viewBox="0 0 32 32"
    width="20"
    height="20"
    fill="none"
    stroke="currentcolor"
    stroke-linecap="round"
    stroke-linejoin="round"
    stroke-width="2"
  >
    <path
      d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
    ></path>
  </svg>
</a></h3>
<ol>
<li>Read the session ID from the signed cookie</li>
<li>Retrieve the stored session from DB</li>
<li>(optional) remove the session &amp; cookie if expired</li>
<li>Get the user ID from the session</li>
<li>(optional) Retrieve the stored user from the DB using the user ID</li>
<li>Decide whether the user is allowed to see the page</li>
</ol>
</div><footer class="vstack gap-md pad-xl stripes"><h2>Next step</h2><a href="https://github.com/foundersandcoders/auth-challenge" target="_blank" rel="noopener" class="button" style="--bg: var(--primary); --bg-hover: var(--primary-dark)">Complete the challenge<svg viewBox="0 0 20 20" fill="currentColor" width="16" height="16"><path fill-rule="evenodd" d="M4.25 5.5a.75.75 0 00-.75.75v8.5c0 .414.336.75.75.75h8.5a.75.75 0 00.75-.75v-4a.75.75 0 011.5 0v4A2.25 2.25 0 0112.75 17h-8.5A2.25 2.25 0 012 14.75v-8.5A2.25 2.25 0 014.25 4h5a.75.75 0 010 1.5h-5z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M6.194 12.753a.75.75 0 001.06.053L16.5 4.44v2.81a.75.75 0 001.5 0v-4.5a.75.75 0 00-.75-.75h-4.5a.75.75 0 000 1.5h2.553l-9.056 8.194a.75.75 0 00-.053 1.06z" clip-rule="evenodd"></path></svg></a></footer></div></main></div></div></div><script type="module" src="/assets/js/checkboxen.js"></script><script src="/assets/js/toggle-button.js"></script><script src="/assets/js/copy-text.js"></script></body></html>