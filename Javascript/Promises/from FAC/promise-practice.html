<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promise practice</title>
    <link
      rel="preload"
      href="/assets/fonts/GT-Eesti-Text-Light-subset.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link rel="icon" href="/assets/favicon.svg" />
    <link href="/assets/css/styles.css" rel="stylesheet" />
  </head>
  <body>
    <div>
      <header class="hstack jc-between pad-lg">
        <a href="/" aria-label="Home"
          ><img src="/assets/images/logo.svg" width="100" alt
        /></a>
        <nav id="global-nav">
          <ul role="list" class="hstack">
            <li>
              <a class="global-nav__link" href="/course/introduction/"
                >Course</a
              >
            </li>
            <li>
              <a class="global-nav__link" href="/resources/introduction/"
                >Resources</a
              >
            </li>
            <li><a class="global-nav__link" href="/about/">About</a></li>
          </ul>
        </nav>
      </header>
      <div class="center">
        <div class="layout">
          <aside></aside>
          <main id="main">
            <div>
              <header class="vstack gap-xl pad-xl stripes">
                <div class="vstack" data-gap="md">
                  <h1 class="highlight bg-primary">Promise practice</h1>
                  <p class="highlight fz-lg">
                    Practice using promises to avoid &quot;callback hell&quot;
                    in asynchronous JavaScript
                  </p>
                  <ul role="list" class="hstack gap-sm wrap">
                    <li
                      class="highlight fz-sm fw-bold"
                      style="--bg: var(--bg-400)"
                    >
                      js
                    </li>
                    <li
                      class="highlight fz-sm fw-bold"
                      style="--bg: var(--bg-400)"
                    >
                      promises
                    </li>
                    <li
                      class="highlight fz-sm fw-bold"
                      style="--bg: var(--bg-400)"
                    >
                      async
                    </li>
                  </ul>
                </div>
                <div class="hstack wrap">
                  <div class="vstack gap-none">
                    <label
                      for="download-command"
                      class="highlight fw-bold"
                      style="--bg: var(--bg-400)"
                      >Download files via CLI</label
                    ><copy-text class="hstack gap-none ai-stretch"
                      ><input
                        id="download-command"
                        readonly
                        value="npx degit 'foundersandcoders/coursebook/src/workshops/promise-practice/starter-files#main' promise-practice" /><button
                        aria-label="Copy"
                        title="Copy"
                        hidden
                      >
                        <svg
                          data-copy
                          width="20"
                          height="20"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                        >
                          <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                            d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
                          ></path></svg
                        ><svg
                          hidden
                          data-success
                          width="20"
                          height="20"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                        >
                          <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                            d="M5 13l4 4L19 7"
                          ></path>
                        </svg></button
                    ></copy-text>
                  </div>
                  <a
                    href="https://github.com/foundersandcoders/coursebook/issues/new?title=%5Bworkshops%2Fpromise-practice%5D&amp;labels=feedback"
                    target="_blank"
                    rel="noopener"
                    class="button"
                    >Leave feedback<svg
                      viewBox="0 0 20 20"
                      fill="currentColor"
                      width="16"
                      height="16"
                    >
                      <path
                        fill-rule="evenodd"
                        d="M10 2c-2.236 0-4.43.18-6.57.524C1.993 2.755 1 4.014 1 5.426v5.148c0 1.413.993 2.67 2.43 2.902 1.168.188 2.352.327 3.55.414.28.02.521.18.642.413l1.713 3.293a.75.75 0 001.33 0l1.713-3.293a.783.783 0 01.642-.413 41.102 41.102 0 003.55-.414c1.437-.231 2.43-1.49 2.43-2.902V5.426c0-1.413-.993-2.67-2.43-2.902A41.289 41.289 0 0010 2zM6.75 6a.75.75 0 000 1.5h6.5a.75.75 0 000-1.5h-6.5zm0 2.5a.75.75 0 000 1.5h3.5a.75.75 0 000-1.5h-3.5z"
                        clip-rule="evenodd"
                      ></path></svg
                  ></a>
                </div>
              </header>
              <div style="margin: 4rem 0" class="flow">
                <p>
                  Running functions in sequence (one after another) is a common
                  requirement. For example, triggering animations in order, or
                  requesting some data then sending that response on to another
                  API.
                </p>
                <p>
                  If your code is synchronous it’s easy to make it run in order:
                  that’s what JavaScript does automatically. Each line of code
                  runs one by one:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"amber"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// etc</span></code></pre>
                <p>
                  However once you have asynchronous code this gets harder to
                  manage. You don’t know how long each bit of code will take, so
                  you have to make sure each line of code waits for the previous
                  one.
                </p>
                <p>
                  We’ve previously
                  <a href="/workshops/functions-callbacks-async/"
                    >used callbacks to solve this</a
                  >:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token function">light</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token function">light</span><span class="token punctuation">(</span><span class="token string">"amber"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token function">light</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// etc</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
                <p>
                  However this quickly gets difficult to manage as each new
                  callback introduces another level of nesting.
                </p>
                <p>
                  Promises make it easier to run code in sequence. A promise
                  object’s <code>.then</code> method returns a
                  <em>new promise</em> that resolves with whatever value you
                  returned from the callback you passed in.
                </p>
                <p>
                  Here we have a promise that will eventually resolve with the
                  value <code>1</code>:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token keyword">const</span> onePromise <span class="token operator">=</span> <span class="token function">resolvesWithOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
                <p>
                  We can access this value using the promise’s
                  <code>.then</code> method:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token keyword">const</span> onePromise <span class="token operator">=</span> <span class="token function">resolvesWithOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>onePromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Logs 1 (eventually)</span></code></pre>
                <p>
                  Since <code>.then</code> returns a new promise we can assign
                  it to a variable and use it again:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token keyword">const</span> onePromise <span class="token operator">=</span> <span class="token function">resolvesWithOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> fivePromise <span class="token operator">=</span> onePromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> value <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>fivePromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Logs 5 (eventually)</span></code></pre>
                <p>
                  Here we wait for <code>onePromise</code> to resolve with
                  <code>1</code>, then multiply that by <code>5</code> and
                  return the result. This creates a <em>new promise</em> that
                  will eventually resolve with <code>5</code>. We can then
                  access this value by using the <code>.then</code> method of
                  this second promise.
                </p>
                <p>
                  Since each <code>.then</code> returns a new promise object we
                  can avoid all the extra variables and chain the
                  <code>.then</code> methods directly:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token function">resolvesWithOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;- returns a promise that resolves with 1</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> value <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// &lt;- returns a promise that resolves with (1 * 5)</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;- returns a promise that resolves with undefined</span><br><span class="token comment">// Logs 5 (eventually)</span></code></pre>
                <p>
                  This example is a bit silly since multiplication is
                  synchronous—we can just use <code>value * 5</code> directly
                  without the second <code>then</code>. However since
                  <code>.then</code>s always return new promises we can chain
                  <em>asynchronous</em> operations together to avoid nesting our
                  callbacks.
                </p>
                <p>
                  Imagine we had another function that multiplied numbers after
                  2 seconds:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token function">resolvesWithOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> fivePromise <span class="token operator">=</span> <span class="token function">multipliesEventually</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  fivePromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">finalValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>finalValue<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Logs 5 (eventually)</span></code></pre>
                <p>
                  Here we’re starting to recreate our “callback hell” from the
                  traffic lights example. Each new asynchronous operation means
                  nesting a callback one level deeper.
                </p>
                <p>
                  However since each <code>.then</code> returns a promise we can
                  return our <code>fivePromise</code> promise and access in it
                  the <em>next</em> <code>.then</code>:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token function">resolvesWithOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> fivePromise <span class="token operator">=</span> <span class="token function">multipliesEventually</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> fivePromise<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">finalValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>finalValue<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Logs 5 (eventually)</span></code></pre>
                <p>
                  Since all we do with the <code>fivePromise</code> variable is
                  return it we can skip defining it and simplify our code to:
                </p>
                <pre
                  class="language-js"
                ><code class="language-js"><span class="token function">resolvesWithOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;- returns a promise that resolves with 1</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">multipliesEventually</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// &lt;- returns a promise that resolves with (1 * 5)</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">finalValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>finalValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Logs 5 (eventually)</span></code></pre>
                <p>
                  The magic part is that we can return sync <em>or</em> async
                  operations from a <code>.then</code>—promise objects don’t
                  care what kind of value is inside them. The next
                  <code>.then</code> in the chain will always wait for the
                  previous value to be ready.
                </p>
                <h3 id="challenge-1-traffic-lights-again">
                  Challenge 1: traffic lights again
                  <a
                    class="heading-anchor"
                    href="#challenge-1-traffic-lights-again"
                  >
                    <svg
                      viewBox="0 0 32 32"
                      width="20"
                      height="20"
                      fill="none"
                      stroke="currentcolor"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                    >
                      <path
                        d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
                      ></path>
                    </svg>
                  </a>
                </h3>
                <p>
                  You’re going to recreate the traffic lights from the callback
                  workshop, but using promises to avoid nesting your callbacks.
                </p>
                <ol>
                  <li>
                    Download the starter files and open
                    <code>challenge-1/index.html</code>
                  </li>
                  <li>
                    The pre-defined <code>wait</code> function is like
                    <code>setTimeout</code>, except it returns a promise that
                    resolves after waiting the specified number of milliseconds
                  </li>
                  <li>
                    Use <code>wait</code> to write a
                    <code>light</code> function. This should:
                    <ul>
                      <li>Take a colour string argument</li>
                      <li>Wait 1 second then log this string</li>
                    </ul>
                  </li>
                  <li>
                    Use <code>light</code> to log a sequence of traffic light
                    colours with a one second pause between each E.g.
                    <code
                      >&quot;green&quot;, &quot;amber&quot;, &quot;red&quot;,
                      &quot;amber&quot;, &quot;red&quot;, &quot;green&quot;,
                      &quot;finished&quot;</code
                    >
                  </li>
                </ol>
                <p>
                  Try not to let your callbacks go beyond a single level of
                  nesting!
                </p>
                <h3 id="challenge-2-pokemon-shape">
                  Challenge 2: Pokémon shape
                  <a class="heading-anchor" href="#challenge-2-pokemon-shape">
                    <svg
                      viewBox="0 0 32 32"
                      width="20"
                      height="20"
                      fill="none"
                      stroke="currentcolor"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                    >
                      <path
                        d="M18 8 C18 8 24 2 27 5 30 8 29 12 24 16 19 20 16 21 14 17 M14 24 C14 24 8 30 5 27 2 24 3 20 8 16 13 12 16 11 18 15"
                      ></path>
                    </svg>
                  </a>
                </h3>
                <p>
                  You probably won’t be programming traffic lights using
                  JavaScript, so let’s try a more realistic example.
                </p>
                <p>
                  APIs often require you to make request to multiple different
                  URLs to get all the data you need. For example the
                  <a href="https://pokeapi.co/">PokéAPI</a> returns Pokémon
                  objects with properties containing followup URLs with extra
                  information (since it would make for a very big initial
                  response if they included everything).
                </p>
                <ol>
                  <li>Open <code>challenge-2/index.html</code></li>
                  <li>
                    Use <code>fetch</code> to request data from
                    <code
                      >&quot;https://pokeapi.co/api/v2/pokemon/pikachu&quot;</code
                    >
                  </li>
                  <li>
                    Once your code has the response it should grab the
                    <code>species.url</code> property and make a new request to
                    that
                  </li>
                  <li>
                    Once your code has that response it should grab the
                    <code>shape.url</code> property and make a final request to
                    that
                  </li>
                  <li>
                    Log the final response body. It should look something like
                    this:
                    <pre
                      class="language-json"
                    ><code class="language-json"><span class="token punctuation">{</span><br> <span class="token property">"awesome_names"</span><span class="token operator">:</span> <span class="token punctuation">[</span>...<span class="token punctuation">]</span><span class="token punctuation">,</span><br> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span><br> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"quadruped"</span><span class="token punctuation">,</span><br> <span class="token property">"names"</span><span class="token operator">:</span> <span class="token punctuation">[</span>...<span class="token punctuation">]</span><span class="token punctuation">,</span><br> <span class="token property">"pokemon_species"</span><span class="token operator">:</span> <span class="token punctuation">[</span>...<span class="token punctuation">]</span><br><span class="token punctuation">}</span></code></pre>
                  </li>
                </ol>
                <p>
                  Try not to let your callbacks go beyond a single level of
                  nesting!
                </p>
              </div>
            </div>
          </main>
        </div>
      </div>
    </div>
    <script type="module" src="/assets/js/checkboxen.js"></script>
    <script src="/assets/js/toggle-button.js"></script>
    <script src="/assets/js/copy-text.js"></script>
  </body>
</html>
